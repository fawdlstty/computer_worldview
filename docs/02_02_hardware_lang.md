# 第二章 计算机语言

## 第二节 面向机器语言

通用型芯片具有解析并执行一些指令的能力，根据芯片复杂度确定可执行指令数量。对这些指令，我们将其称之为汇编语言。

通常根据芯片厂家的不同及汇编语言编译器的不同，汇编语言可以分为多种类型，比如Intel系列x86指令集编译器有masm32（用于Windows平台的汇编编译器）、nasm（用于linux平台的汇编编译器）等。

此处我们以C语言及masm32汇编举例。

```cpp
// 定义函数
int test () {
    // 执行计算，并放入局部变量
    int a = 5 + 4;
    // 返回局部变量
    return a;
}
```

等价汇编：

```asm
; 定义函数
push ebp
mov ebp, esp

; 执行计算，并放入局部变量
sub esp, 4
mov eax, 5
add eax, 4
mov dword ptr [ebp], eax

; 返回局部变量
mov eax, dword ptr [ebp]
mov esp, ebp
pop ebp
ret
```

下面我来给个解读一下这样的代码。首先对于定义函数部分，C语言通过函数头、函数体的方式来定义，语法为：

```cpp
返回类型 函数名 (参数列表) {
    函数体
}
```

在汇编里面呢？可以看到，函数结构几乎没有了。因为CPU可不管你是不是函数，它只会按照逻辑顺序执行。我们悉知的将一些抽象的、公共的功能，提取为函数的方法，在汇编语言里，其实是，保存环境、执行函数代码、恢复环境。

可以看到汇编语言里，函数开头及结束，有这样的代码：

```asm
push ebp
mov ebp, esp

; ...

mov esp, ebp
pop ebp
ret 0
```

我们来逐个解读。

应用程序栈也是一种栈，栈先进后出，同时应用程序的栈向上生长。

`push ebp`，含义为取出栈基址指针（Base Pointer）并将其压入（Push）栈（Stack）中。此处的栈，意为应用程序栈。比如我们有耳闻的著名异常：stack overflow（栈溢出）即指的这个栈。ebp这词在不同位数下具有不同写法。16位8086指令集里写作bp（Base Pointer），32位x86里写作ebp（Extended Base Pointer）64位amd64里写作rbp（不是RBQ）。

`push ebp`这个指令等价于两条指令组合：`mov dword ptr [esp], ebp`、`sub esp, 4`。我们向栈存数据时，首先将数据移动至栈顶指针指向的内存区域，然后将栈顶指针-4（以字节为单位访问内存时，32位数据占4字节）。

然后是`mov ebp, esp`，这句意思是将esp内容移动至ebp。由于我们进入了一个新的函数环境，老环境暂时不用了，于是我们将栈顶至栈底的空间封存，重置这两个指针为栈上方未使用到的空间，这样就能使得函数环境隔离，避免函数内部运行影响外部调用者。

好。然后是函数末尾，上面两句反过来，可以理解为，函数执行完毕，恢复回之前的调用者环境。最后一句`ret 0`代表将函数执行地址转为调用者所在地址。后接的数字代表参数占用空间字节数。一般一个参数占用4字节，这个数字在32位环境一般是参数数量*4这样子。

然后是函数体部分代码：

```asm
; ...

; 执行计算，并放入局部变量
sub esp, 4
mov eax, 5
add eax, 4
mov dword ptr [ebp], eax

; 返回局部变量
mov eax, dword ptr [ebp]

; ...
```

`sub esp, 4`，这句代码含义是，栈顶向上空余出4字节，代表这部分空间有变量需要用到，也就是局部变量a。由于函数释放时，直接恢复调用者的栈空间，局部变量直接被释放，所以不需要担心释放的问题（RAII后面再说）。

`mov eax, 5`，这句含义为，向寄存器eax中存入一个立即数（immediate）。
